# 数据结构

## 1.0 绪论

## 1.1 基本概念

### 数据

​	**数据项**：如年龄、性别。

​	多个数据项的结合起来成为一个整体称为**数据元素**。

### 数据结构三要素

#### 逻辑结构

##### 集合

##### 线性结构

​	数据元素之间是一对一的关系.

##### 树形结构

##### 图结构

#### 物理结构

##### 顺序存储

##### 链式存储

##### 索引存储

##### 散列存储

### 算法

​	程序=数据结构+算法

> **特性**：
>
> 有穷性
>
> ​	算法必须是有穷的，程序可以是无穷的。
>
> 确定性
>
> ​	相同的输入只能得到相同的输出
>
> 可行性
>
> 输入
>
> ​	有零个或者多个输入
>
> 输出
>
> ​	有一个或者多个输出

### 时间复杂度	

```c
void loveYou(int n) {
    int i=1;
    while(i<=){
        i++;
        printf("I Love Yuou %d\n", i);
    }
    printf("I Love You More Than %d\n", n);
}

# T(n)=3n+3  
# T(n)=O(n)
```

时间复杂度大小判断

> O(1)<O(log2^n)<O(n)<O(nlog2^n)<O(n^2)<O(2^n)<O(n!)<O(n^n)

```c
void loveYou(int n) {
	int i=1;
    while(i<=n){
        i++
        printf("I Love You %d\n", i);
        for(int j=1;j<=n;j++){
            printf("I am Iron Man\n");
        }
        printf("I Love You More Than %d\n", n);
    }
}

T(n)=O(n)+O(n^2)=O(n^2)
```

### 空间复杂度

|   内存   |
| :------: |
| 程序代码 |
|   数据   |
|          |

```c
void loveYou(int n){
	int i=1;
	while(i<=n){
		i++;
		printf("I Love You %d\n",i);
	}
	printf("I Love You More Than %d\n",n);
}
```

无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为S(n)=O(1)

```c
void test(int n){
	int flag[n];
	int i;
}
```

假设一个int变量占4B

则所需内存空间=4+4n+4=4n+8 (n、flag、i)

S(n)=O(n)

```c
void loveYou(int n){
	int a,b,c;
	if(n>1){
		loveYou(n-1);
	}
    printf("I Love You %d\n",n);
}

int main(){
    loveYou(5);
}
```

S(n)=O(n)

```c
void loveYou(int n){
	int flag[n];
	if(n>1){
		loveYou(n-1);
	}
    printf("I Love You %d\n",n);
}

int main(){
    loveYou(5);
}
```

1+2+3+...+n=[n(n+1)]/2=1/2*n^2+1/2*n

S(n)=O(n^2)
总结：看递归调用的深度

## 2.1线性表的定义和基本操作

#### 定义

​	线性表是具有**相同**数据类型的n个数据元素的有限序列，其中n为表长。

​	L=（a1,a2,....,an)

​	除第一个元素外，每个元素有且仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继。

#### 基本操作

1. 初始化表
2. 销毁操作
3. 插入操作
4. 删除操作
5. 按值查找
6. 按位查找

## 2.2.1顺序表的定义

​	用顺序存储的方式实现线性表顺序存储，把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。

​	实现--动态分配

```c
#include <stdlib.h>
#define InitSize 10
typedef struct{
    int *data;
    int MaxSize;
    int length;
}SeqList;

void InitList(SeqList *L){
    L.data=(int *)malloc(InitSze*sizeof(int));
    L.length=0;
    L.MaxSize=InitSize;
}

void IncreaseSize(SeqList *L, int len){
    int *p=L.data;
    L.data=(int *)malloc((L.MaxSize+len)*sizeof(int));
    for(int i=0; i<L.length; i++){
        L.data[i]=p[i];
    }
    L.MaxSize=L.MaxSize+len;
    free(p);
}

int main(){
    SeqList L;
    InitList(&L);
    IncreaseSize(L,5);
    return 0;
}
```

## 2.2.2.1顺序表的插入删除

```c
bool ListInsert(SqList *L, int i, int e){
    if(i < 1 || i > L->length+1 || L->length == MAXSIZE)
        return false;
    for(int j = L->length; j >= i; j--)
        L->data[j] = L->data[j-1];
    L->data[i-1] = e;
    L->length++;
    return true;
}
```

```c
bool ListDelete(SqList *L, int i, int *e){
	if(i < 1 || i > L->length)
		return false;
    *e = L->data[i-1];
    for(int j = i; j < L->length; j++)
        L->data[j-1] = L->date[j];
    L->length--;
    return true;
}
```

## 2.2.2.2顺序表的查找

1. 按位查找 GetElem

   ```c
   int GetElem(SqList *L, int i){
       return L->data[i-1];
   }
   ```

2. 按值查找 LocateElem

   ```c
   int LocateElem(SqList *L, int e){
       for(int i = 0; i < L->length; i++)
           if(L->data[i] == e)
               return i+1;
       return 0;
   }
   ```

## 2.3.1单链表的定义

​	链式存储的线性表

### 带头节点初始化

```c
bool InitList(LinkList L){
    L = (LNode *)malloc(sizeof(LNode));
    if(L == NULL)
        return false;
    L->next = NULL;
    return true;
}
```

### 不带头节点初始化

```c
bool InitList(LinkList L){
    L->next = NULL;
    return true;
}
```

## 2.3.2.1单链表的插入删除

1. 插入操作

   在表L中的第i个位置上插入指定元素e

   ```c
   bool ListInsert(LinkList L, int i, int e){
       if(i < 1)
           return false;
       LinkList p = L;
       int j = 0;
       while(p != NULL && j < i-1){
           p = p->next;
           j++;
       }
       if(p == NULL)
           return false;
       LNode *s = (LNode *)malloc(sizeof(LNode));
       if(s == NULL)
           return false;
       s->data = e;
       s->next = p->next;
       p->next = s;
       return true;
   }
   ```

2. 删除操作

   删除表L中的第i个节点，并返回删除节点的数据

   ```c
   bool ListDelete(LinkList L, int i, int *e){
       if(i < 1)
           return false;
       LNode *p = L;
       int j = 0;
       while(p != NULL && j < i-1){
           p = p->next;
           j++;
       }
       if(p == NULL || p->next == NULL)
           return false;
       LNode *q = p->next;
       p->next = q->next;
       *e = q->data;
       free(q);
       return true;
   }
   ```

## 2.3.2.2单链表的查找

### 按位查找

```c
LNode *GetElem(LinkList L, int i){
	if(i < 0)
        return NULL;
    LNode *p = L;
    int j = 0;
    while(p != NULL && j < i){
        p = p->next;
        j++;
    }
    return p;
}
```

### 按值查找

```c
LNode *LocateElem(LinkList L, int e){
	LNode *p = L;
    while(p != NULL && p->data != e){
        p = p->next;
    }
    return p;
}
```

## 2.3.2.3单链表的建立

### 尾插法

```c
bool LinkList_TailInsert(LinkList *L){
    int e;
    *L = (LinkList)malloc(sizeof(LNode));
    if(*L == NULL)
        return false;
    LNode *r = *L;
    scanf("%d", &e);
    while(e != 9999){
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if(s == NULL)
            return false;
        s->data = e;
        r->next = s;
        r = s;
        scanf("%d", &e);
    }
    r->next = NULL;
    return true;
}
```



### 头插法

```c
bool Linkist_HeadInsert(LinkList *L){
    int e;
    *L = (LinkList)malloc(sizeof(LNode));
    if(L == NULL)
        return false;
    (*L)->next = NULL;
    scanf("%d", &e);
    while(e != 9999){
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if(s == NULL)
            return false;
        s->data = e;
        s->next = (*L)->next;
        (*L)->next = s;
        scanf("%d", &e);
    }
    return true;
}
```

## 2.3.3双链表

## 2.3.4循环链表

## 2.3.5静态链表

## 2.3.6顺序表和链表的比较

## 3.1.1栈的基本概念

## 3.1.2栈的顺序存储实现

## 3.1.3栈的链式存储实现

## 3.2.1队列的基本概念

​	只允许在一端进行插入在另一端删除的线性表

## 3.2.2队列的顺序实现

### 结构

```c
#define MAXSIZE 10
typedef struct{
    int data[MAXSIZE];
    int front;
    int rear;
}SqQueue;
```

### 初始化

```c
void InitSqQueue(SqQueue *S){
	S->front = 0;
    S-> rear = 0;
}
```

### 增加

```c
bool EnSqQueue(SqQueue *S, int e){
	if((S->rear+1)%MAXSIZE == S->front)
        return false;
    S->data[S->rear] = e;
    S->rear = (S->rear+1)%MAXSIZE;
    return true;
}
```

### 减少

```c
bool DeSqQueue(SqQueue *S, int *e){
	if(S->rear == S->front)
        return false;
    *e = S->data[S->front];
    S->front = (S->front+1)%MAXSIZE;
    return true;
}
```

### 查询

```c
bool GetHead(SqQueue S, int *e){
	if(S.rear == S.front)
        return false;
    *e = S.data[S.front];
    return true;
}
```

## 3.2.3队列的链式实现

## 3.2.4双端队列

## 3.3.1栈在括号匹配中的应用

